/**
 * com.blackducksoftware.integration.eclipse.plugin
 *
 * Copyright (C) 2017 Black Duck Software, Inc.
 * http://www.blackducksoftware.com/
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package com.blackducksoftware.integration.eclipse.views.providers;

import org.apache.commons.lang3.StringUtils;
import org.eclipse.jface.resource.JFaceResources;
import org.eclipse.jface.viewers.ViewerCell;
import org.eclipse.swt.SWT;
import org.eclipse.swt.custom.StyleRange;
import org.eclipse.swt.graphics.Color;
import org.eclipse.swt.widgets.Display;

import com.blackducksoftware.integration.eclipse.internal.ComponentModel;

public class VulnerabilityCountColumnLabelProvider extends ComponentTableColumnLabelProvider {
	private final ComponentTableContentProvider dependencyTableViewCp;

	public VulnerabilityCountColumnLabelProvider(final ComponentTableContentProvider dependencyTableViewCp) {
		super();
		this.dependencyTableViewCp = dependencyTableViewCp;
	}

	public VulnerabilityCountColumnLabelProvider(final int width, final int alignment, final ComponentTableContentProvider dependencyTableViewCp) {
		super(width, alignment);
		this.dependencyTableViewCp = dependencyTableViewCp;
	}

	@Override
	public String getText(final Object input) {
		if (input instanceof ComponentModel) {
			if (!((ComponentModel) input).getComponentIsKnown()) {
				return VALUE_UNKNOWN;
			}
			final int[] vulnSeverityCount = ((ComponentModel) input).getVulnerabilityCount();
			final String highString = vulnSeverityCount[0] < 1000 ? vulnSeverityCount[0] + "" : "999+";
			final String mediumString = vulnSeverityCount[1] < 1000 ? vulnSeverityCount[1] + "" : "999+";
			final String lowString = vulnSeverityCount[2] < 1000 ? vulnSeverityCount[2] + "" : "999+";
			final String text;
			if(vulnSeverityCount.length == 4){
				final String premiumString = vulnSeverityCount[3] < 1000 ? vulnSeverityCount[3] + "" : "999+";
				text = StringUtils.join(new Object[] { " " + highString, mediumString, lowString, premiumString + " " }, " : ");
			}else{
				text = StringUtils.join(new Object[] { " " + highString, mediumString, lowString + " " }, " : ");
			}
			return text;
		}
		return "";
	}

	@Override
	public String getTitle() {
		return "Security Risk";
	}

	public ComponentTableContentProvider getDependencyTableViewCp() {
		return this.dependencyTableViewCp;
	}

	@Override
	public String getToolTipText(final Object input){
		final StringBuilder toolTipTextBuilder = new StringBuilder();
		final String cellText = this.getText(input);
		final String[] vulnCount = cellText.trim().split(":");
		if(vulnCount.length == 4){
			int totalVulnerabilities = 0;
			for(final String intString : vulnCount){
				totalVulnerabilities += Integer.parseInt(intString.trim());
			}
			final int identifiedVulnerabilities = totalVulnerabilities - Integer.parseInt(vulnCount[3].trim());
			if(totalVulnerabilities > identifiedVulnerabilities){
				toolTipTextBuilder.append(identifiedVulnerabilities);
				toolTipTextBuilder.append(" out of ");
				toolTipTextBuilder.append(totalVulnerabilities);
				toolTipTextBuilder.append(" detected vulnerabilities identified. Connect to your Hub instance for better results.");
			}
		}
		if(toolTipTextBuilder.toString().equals("")){
			return null;
		}
		return toolTipTextBuilder.toString();
	}

	@Override
	public void styleCell(final ViewerCell cell) {
		if (cell.getText().equals(VALUE_UNKNOWN)) {
			cell.setText("");
			return;
		}
		final String[] vulnChunks = cell.getText().split(":");
		cell.setFont(JFaceResources.getTextFont());
		final Display display = Display.getCurrent();
		final String noVulns = " 0 ";
		final Color textColor = display.getSystemColor(SWT.COLOR_WHITE);
		final Color highColor = decodeHex(display, "#b52b24");
		final Color mediumColor = decodeHex(display, "#eca4a0");
		final Color lowColor = decodeHex(display, "#999999");
		final Color premiumColor = decodeHex(display, "#2d343e");
		final Color invisible = display.getSystemColor(SWT.COLOR_WIDGET_BACKGROUND);
		final Color[] vulnColors = new Color[] { highColor, mediumColor, lowColor, premiumColor };
		final StyleRange[] styleRanges = new StyleRange[vulnChunks.length];
		int lastLabelEnd = 0;
		if(vulnChunks.length == 4){
			cell.setText(String.format(
					"%-5s %-5s %-5s %-5s",
					StringUtils.center(vulnChunks[0], 5), StringUtils.center(vulnChunks[1], 5), StringUtils.center(vulnChunks[2], 5), StringUtils.center(vulnChunks[3], 5)));
		}else{
			cell.setText(String.format(
					"%-5s %-5s %-5s",
					StringUtils.center(vulnChunks[0], 5), StringUtils.center(vulnChunks[1], 5), StringUtils.center(vulnChunks[2], 5)));
		}
		for (int i = 0; i < vulnChunks.length; i++) {
			final int labelStart = cell.getText().indexOf(vulnChunks[i], lastLabelEnd);
			final int labelSize = vulnChunks[i].length();
			if (vulnChunks[i].equals(noVulns)) {
				styleRanges[i] = new StyleRange(labelStart, labelSize, invisible, invisible);
			} else {
				styleRanges[i] = new StyleRange(labelStart, labelSize, textColor, vulnColors[i]);
			}
			lastLabelEnd = labelStart + labelSize;
		}
		cell.setStyleRanges(styleRanges);
	}

}
